@using TGHub.Application.Resources
@using TGHub.Application.Services.Channels
@using TGHub.Application.Services.Spammers
@using TGHub.Blazor.Resources
@using TGHub.Domain.Entities
@using TGHub.Domain.Enums
@using TGHub.Application.Common.Filtering
@using TGHub.Application.Interfaces
@using TGHub.Application.Common.Exceptions
@inject IStringLocalizer<UiStrings> UiStringsLoc
@inject IStringLocalizer<NotificationStrings> NotificationStringsLoc
@inject IToastService ToastService
@inject ILogger<ChannelModal> Logger
@inject IServiceProvider ServiceProvider

<div>
    <div class="flex justify-between gap-3">
        <label class="font-bold">@UiStringsLoc[UiStrings.Administrators]</label>
        <button type="button"
                class="text-[@ColorStrings.C5]/80 hover:text-[@ColorStrings.C5]
                        @(_isRefreshing ? "animate-spin" : "")"
                title="@UiStringsLoc[UiStrings.RefreshFromTg]"
                disabled="@_isRefreshing"
                @onclick="@RefreshFromTgAsync">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-6 h-6">
                <path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0013.803-3.7M4.031 9.865a8.25 8.25 0 0113.803-3.7l3.181 3.182m0-4.991v4.99"/>
            </svg>
        </button>
    </div>
    <div class="flex flex-wrap gap-2 p-2">
        @foreach (var administrator in _channel.Administrators.Where(a => a.IsActive))
        {
            <UserTile User="@administrator.Administrator"
                      IsCrowned="@(administrator.Role == ChannelRole.Owner)" CrownTitle="@UiStringsLoc[UiStrings.Owner]"/>
        }
    </div>
</div>

<div class="mt-3 flex gap-2">
    <label class="font-bold">@UiStringsLoc[UiStrings.Spam]</label>
    <SimpleSwitcher Checked="@_channel.OffensiveSpamOn" Click="@ShowSpamSwitchModal"/>
</div>

@if (_bannedSpammers.Any())
{
    <div class="mt-3">
        <label class="font-bold">@UiStringsLoc[UiStrings.BannedSpammers]</label>
        <div class="grid grid-cols-3 gap-2 max-h-[15-rem] overflow-y-auto">
            @foreach (var bannedUser in _bannedSpammers)
            {
                <button type="button" class="drop-shadow active:drop-shadow-none"
                        @onclick="@(() => ShowBannedUserModal(bannedUser))">
                    @bannedUser.TelegramId
                </button>
            }
        </div>
    </div>
}

@code {

    [CascadingParameter]
    private IModalService ModalService { get; set; } = null!;

    [CascadingParameter]
    private BlazoredModalInstance Modal { get; set; } = null!;

    [Parameter]
    public int ChannelId { get; set; }

    [Parameter]
    public EventCallback ChannelRefreshed { get; set; }

    private bool _isRefreshing;
    private Channel _channel = new();
    private List<Spammer> _bannedSpammers = new();

    protected override async Task OnParametersSetAsync()
    {
        await RefreshFromDbAsync();
    }

    private async Task RefreshFromDbAsync()
    {
        await using var scope = ServiceProvider.CreateAsyncScope();
        var channelService = scope.ServiceProvider.GetRequiredService<IChannelService>();
        var channel = await channelService.FirstOrDefaultAsync(ch => ch.Id == ChannelId);
        if (channel == null)
        {
            ToastService.ShowError(string.Format(NotificationStringsLoc[NotificationStrings.MissingChannel], ChannelId));
            await Modal.CloseAsync();
            return;
        }
        _channel = channel;

        var spammerService = scope.ServiceProvider.GetRequiredService<ISpammerService>();
        _bannedSpammers = await spammerService.ListAsync(new FilterBase<Spammer>
        {
            Where = s => s.ChannelId == ChannelId && s.BannDateTime != null,
            SortBy = s => s.BannDateTime!,
            SortDirection = SortDirection.Descending
        });
    }

    private async Task RefreshFromTgAsync()
    {
        if (_isRefreshing)
        {
            return;
        }
        _isRefreshing = true;
        StateHasChanged();
        try
        {
            await using var scope = ServiceProvider.CreateAsyncScope();

            var tgBotClient = scope.ServiceProvider.GetRequiredService<ITgHubTelegramBotClient>();
            await tgBotClient.CreateOrUpdateChannelFromTg(_channel.TelegramId);

            await RefreshFromDbAsync();

            Modal.SetTitle(_channel.Name);
            await ChannelRefreshed.InvokeAsync();

            ToastService.ShowSuccess(string.Format(NotificationStringsLoc[NotificationStrings.ChannelRefreshSuccess], _channel.Name));
        }
        catch (NotFoundException e)
        {
            ToastService.ShowError(string.Format(NotificationStringsLoc[NotificationStrings.MissingChannel], _channel.Name));
            Logger.LogError(e, "Error while trying to refresh channel {0}", _channel.Id);
        }
        catch (Exception e)
        {
            ToastService.ShowError(string.Format(NotificationStringsLoc[NotificationStrings.ChannelRefreshError], _channel.Name));
            Logger.LogError(e, "Error while trying to refresh channel {0}", _channel.Id);
        }
        finally
        {
            _isRefreshing = false;
            StateHasChanged();
        }
    }

    private async Task ShowSpamSwitchModal()
    {
        var question = _channel.OffensiveSpamOn ? UiStringsLoc[UiStrings.EnsureSpamOff] : UiStringsLoc[UiStrings.EnsureSpamOn];
        var modal = ModalService.Show<YesCancelModal>(string.Format(question, _channel.Name));
        var result = await modal.Result;
        if (result.Confirmed)
        {
            try
            {
                await using var scope = ServiceProvider.CreateAsyncScope();
                var channelService = scope.ServiceProvider.GetRequiredService<IChannelService>();
                var channel = await channelService.FirstOrDefaultAsync(ch => ch.Id == _channel.Id);
                channel!.OffensiveSpamOn = !channel.OffensiveSpamOn;
                await channelService.UpdateAsync(channel);
                _channel.OffensiveSpamOn = channel.OffensiveSpamOn;
            }
            catch (NotFoundException e)
            {
                ToastService.ShowError(string.Format(NotificationStringsLoc[NotificationStrings.MissingChannel], _channel.Name));
                Logger.LogError(e, "Error while trying to set channel {0} SpamOn", _channel.Id);
            }
            catch (Exception e)
            {
                ToastService.ShowError(string.Format(NotificationStringsLoc[NotificationStrings.SubmitError], _channel.Name));
                Logger.LogError(e, "Error while trying to set channel {0} SpamOn", _channel.Id);
            }
        }
    }

    private void ShowBannedUserModal(Spammer spammer)
    {
        ModalService.Show<BannedUserModal>(spammer.TelegramId.ToString(),
            new ModalParameters
            {
                { nameof(BannedUserModal.Spammer), spammer }
            },
            new ModalOptions
            {
                Size = ModalSize.Large
            });
    }

}